<%
if not locals().get("s"):
    s = '''
        create table IF NOT EXISTS article(
            id integer primary key,
            title varchar(255) not null,
            content text
        );
        '''
end

def judge_rust_type(db_type):
	if db_type=="integer":
		return "i64"
	elif 'varchar' in db_type:
		return "String"
	elif 'text' in db_type:
		return "String"
	elif 'datetime' in db_type:
		return "String"
	end
end


data = f('parse_sql', create_sql=s)
table= data['table']
# underscore --> camel
model=''.join(x.capitalize() or '_' for x in table.split('_'))
columns = data['cols']
pk_type=judge_rust_type(columns[0]['type'])
pk_name = columns[0]['name']
insert_col_names = ",".join(c['name']  for c in columns[1:])
insert_col_qmark = ",".join("?"  for c in columns[1:])
update_cols_qmark = ",".join(c['name']+"=?"  for c in columns[1:])
%>
use serde::{Deserialize, Serialize};
use sqlx::{Error, FromRow};

use crate::tables::{DBPool, DBQueryResult};

#[derive(Clone, FromRow, Debug, Serialize, Deserialize)]
pub struct {{model}} {
	%for c in columns:
	pub {{c['name']}}: {{judge_rust_type(c['type'])}},
	%end
}

#[derive(Serialize,Deserialize)]
pub struct Add{{model}} {
	%for c in columns[1:]:
	pub {{c['name']}}: {{judge_rust_type(c['type'])}},
	%end
}

#[derive(Serialize,Deserialize)]
pub struct Update{{model}} {
	%for c in columns[1:]:
	pub {{c['name']}}: {{judge_rust_type(c['type'])}},
	%end
}

#[derive(Serialize,Deserialize)]
pub struct Query{{model}} {
    %c =columns[1]
	pub {{c['name']}}: {{judge_rust_type(c['type'])}},

}

#[derive(Serialize,Deserialize)]
pub struct {{model}}Vo {
	%for c in columns:
	pub {{c['name']}}: {{judge_rust_type(c['type'])}},
	%end
}


impl {{model}} {
    pub async fn insert(t: Add{{model}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        //todo: this is just a template code, write your own business.
        sqlx::query("INSERT INTO {{table}} ({{insert_col_names}}) VALUES ({{insert_col_qmark}})")
        	%for c in columns[1:]:
			.bind(&t.{{c['name']}})
			%end
            .execute(pool)
            .await
    }

    pub async fn delete({{pk_name}}: {{pk_type}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        //todo: this is just a template code, write your own business.
        sqlx::query("DELETE from {{table}} WHERE {{pk_name}} =?")
            .bind(&{{pk_name}})
            .execute(pool)
            .await
    }

    pub async fn update({{pk_name}}: {{pk_type}}, t: Update{{model}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        //todo: this is just a template code, write your own business.
        sqlx::query("UPDATE {{table}} set {{update_cols_qmark}} WHERE {{pk_name}} =?")
            %for c in columns[1:]:
            .bind(&t.{{c['name']}})
            %end
            .bind(&{{pk_name}})
            .execute(pool)
            .await
    }

    pub async fn query(q: Query{{model}}, pool: &DBPool) -> Result<Vec<{{model}}>, Error> {
        //todo: this is just a template code, write your own business.
        sqlx::query_as::<_, {{model}}>("SELECT * FROM {{table}} where {{columns[1]['name']}} = ?")
            .bind(&q.{{columns[1]['name']}})
            .fetch_all(pool)
            .await
    }
    pub async fn query_all(pool: &DBPool) -> Result<Vec<{{model}}>, Error> {
        //todo: this is just a template code, write your own business.
        sqlx::query_as::<_, {{model}}>("SELECT * FROM {{table}}")
            .fetch_all(pool)
            .await
    }
}



#[cfg(test)]
mod tests {
    use crate::tables::init_test_pool;

    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[tokio::test]
    async fn test_all() -> anyhow::Result<()> {
        let pool = init_test_pool().await;

        todo!();

        //todo: uncomment below code and write your tests.
        /*
        let r = {{model}}::insert(Add{{model}} {

        }, &pool).await?;

        assert_eq!(r.rows_affected(), 1);

        let rows = {{model}}::query(Query{{model}} {

        }, &pool).await?;
        assert_eq!(rows.len(), 1);
        assert_eq!(rows[0].id, 1);

        let r = {{model}}::update(1, Update{{model}} {

        }, &pool).await?;
        assert_eq!(r.rows_affected(), 1);

        let rows = {{model}}::query(Query{{model}} {

        }, &pool).await?;
        assert_eq!(rows[0].id, 1);

        let  r = {{model}}::delete(1, &pool).await?;
        assert_eq!(r.rows_affected(),1);

        let rows = {{model}}::query(Query{{model}} {

        }, &pool).await?;
        assert_eq!(rows.len(), 0);

         */


        Ok(())
    }
}