<%
s2='''
create table IF NOT EXISTS article(
    id integer primary key,
    title varchar(255) not null,
    content text
);
'''

if not locals().get("s"):
    s = s2
end

def judge_rust_type(db_type):
	if db_type=="integer":
		return "i64"
	elif 'varchar' in db_type:
		return "String"
	elif 'text' in db_type:
		return "String"
	end
end

data = f('parse_sql', create_sql=s)
table= data['table']
# underscore --> camel
model=''.join(x.capitalize() or '_' for x in table.split('_'))
primary_key_rust_type=judge_rust_type(data['cols'][0]['type'])


%>
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use sqlx::{Error, FromRow};

use crate::tables::{DBPool, DBQueryResult, Table};

#[derive(Clone, FromRow, Debug, Serialize)]
pub struct {{model}} {

}

#[derive(Deserialize)]
pub struct Add{{model}} {

}

#[derive(Deserialize)]
pub struct Update{{model}} {

}

#[derive(Deserialize)]
pub struct Query{{model}} {

}

#[async_trait]
impl Table<{{primary_key_rust_type}}, {{model}}, Query{{model}}, Update{{model}}, Add{{model}}> for {{model}} {
    async fn insert(t: Add{{model}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        /*sqlx::query("INSERT INTO {{table}} (name) VALUES (?)")
            .bind(&t.name)
            .execute(pool)
            .await */
        todo!()
    }

    async fn delete(id: {{primary_key_rust_type}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        /*sqlx::query("DELETE from {{table}} WHERE id =?")
            .bind(id)
            .execute(pool)
            .await*/
        todo!()
    }

    async fn update(id: {{primary_key_rust_type}}, t: Update{{model}}, pool: &DBPool) -> Result<DBQueryResult, Error> {
        /*sqlx::query("UPDATE {{table}} set name=? WHERE id =?")
            .bind(t.name)
            .bind(id)
            .execute(pool)
            .await*/

        todo!()

    }

    async fn query(q: Query{{model}}, pool: &DBPool) -> Result<Vec<{{model}}>, Error> {
        /*sqlx::query_as::<_, {{model}}>("SELECT id, name FROM {{table}} where name = ?")
            .bind(q.name)
            .fetch_all(pool)
            .await*/
        todo!()
    }
}

